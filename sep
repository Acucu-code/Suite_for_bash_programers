#!/bin/sh
# oxr 2025
# Separa instancias y puede ejecutar ordenes compuestas con cada una de ellas
#
# \\r    sep [-E|-L|-T]|[-s|-S SEP] [-R] [(+|-)N] [-O 'orden..$sep_C..orden..'] -A archivo|instancias
#
# Opciones generales:
# '-A' lee instancias de archivo
# '-O' orden/es a ajecutar por cada instancia; de no darse, estas se mostraran.
# '$sep_C' literal, es la variable que contiene cada instancia
# '--' fin de opciones
# 'instancias' puede ser: $insts|instSEPinst...|o nada si se lee desde archivo
# Opciones de instancia:
# '-E' separador espacio ' ', por defecto
# '-L' separador salto de linea
# '-T' separador tabulador
# '-s' separador, se tomara como entre espacios,' SEP '
# '-S' separador, sin espacios 'SEP'
# '-N' no strip, mantener espacios extra y tabuladores. '+N' no, por defecto
# '-R' sin retorno de carro. '+R' con retorno
#
# \\r    sep -s $S -O '$L && I=$I$sep_C$S ; parp_fun $sep_C ; $W || R=$R$E' "$@"
#
# \\r    sep -S - asd-123-qwe - -E asd 123 qwe -s + asd + 123 + qwe
#
# Las opciones son en mayusculas porque puede haber conflicto con las opciones
# de otros programas incluidos en la orden. Bugs con 'tize' en la orden
#
# Tema espacios tabuladores y comillas
# Tenemos una linea de fstab con tabuladores
# x="/dev/sda1		/									ext3	noatime,lazytime,errors=remount-ro		0	1"
#
# echo "$x" -- respeta
#	/dev/sda1		/									ext3	noatime,lazytime,errors=remount-ro		0	1
#
# echo $x -- reemplaza cada secuencia de tabs por un espacio
#	/dev/sda1 / ext3 noatime,lazytime,errors=remount-ro 0 1
#
# sep $x || sep -N $x -- no reconoce los tabs, separa por defecto(espacio), la salida no difiere entre echo "$sep_C" y echo $sep_C
#	/dev/sda1
#	/
#	ext3
#	noatime,lazytime,errors=remount-ro
#	0
#	1
#
# sep "$x" -- reconoce los tabs y no separa, la salida 'echo $sep_C' elimina tabs
#	/dev/sda1 / ext3 noatime,lazytime,errors=remount-ro 0 1
#
# sep -N "$x" -- la salida 'echo "$sep_C"' mantiene los tabs
#	/dev/sda1		/									ext3	noatime,lazytime,errors=remount-ro		0	1
#
# EN PROCESO - INCLUIBLE - FUNCIONANDO   ⧵∕


sep(){
local sp=" " it="" sep_C="" sep_or="" st=false nr="" tb='	' rt='
'
# sep_C comodin - sp separador - sep_or orden - it instancias - st strip  - tb tabulador - rt salto_de_linea - nr no_return
[ $# -ne 0 ] || { infsh ~/code/sep 3 24 -c 2 -b sep_C ; return ;}

until [ $# -eq 0 ] ; do case $1 in # opciones generales
	-A) while read sep_C ; do it="$it$sep_C$rt" ; done < "$2" ; it=${it%$rt} ; shift 2 ;;
	-O) sep_or="$2" ; shift 2 ;;
	-s) sp=" $2 " ; shift 2 ;;
	-S) sp="$2" ; shift 2 ;;
	-L) sp="$rt" ; shift ;;
	-T) sp="$tb" ; shift ;;
	-E) sp=" " ; shift ;;
	-N) st=true ; shift ;;
	-R) nr="-n" ; shift ;;
	--) shift ; break ;;
	*) break ;;
esac ; done

[ ${#it} -ne 0 ] || it=$@

until [ "$sep_C" = "$it" ] ; do # instancias
	set -- $it
	while : ; do case $1 in # opciones en instancia
		-s) sp=" $2 " ; shift 2 ;;
		-S) sp="$2" ; shift 2 ;;
		-L) sp="$rt" ; shift ;;
		-T) sp="$tb" ; shift ;;
		-E) sp=" " ; shift ;;
		-N) st=true ; shift ;;
		+N) st=false ; shift ;;
		-R) nr="-n" ; shift ;;
		+R) nr="" ; shift ;;
		*) break ;;
	esac ; done

	it=$@ sep_C=${it%%$sp*} it=${it#*$sp}

	[ ${#sep_or} -ne 0 ] && eval "$sep_or" || { $st && echo $nr "$sep_C" || echo $nr $sep_C ;}
done
}


[ ${0##*/} != sep ] || sep "$@"
#
