#!/bin/sh
# oxr 2025
# Asigna a una o mas variables la salida de una orden o registros de un archivo;
#  por linea y campo. Incluir '. varize' para que la asignacion surta efecto
#
# \\r    varize [-e] (-a archivo) [-l lº] [-n [cº [rº]]] {-m} var {var var... --} (orden)
#
# '-e'  muestra el valor
# '-a'  archivo del que leer, excluye 'orden' y viceversa
# '-s'  separador de campos
# '-n'  Reparte desde cº campo hasta rº, o asigna a variables declaradas si no rº.
# ···    Si rº=0, habra reparto hasta el final; si rº, y hay resto, a la ultima.
# '-l'  lee de esa linea. Si no -n, se repartira entre las variables.
# ···    Si lº=0 sera la ultima linea.
# '-m'  multiples variables '--' fin de variables
# 'var' nombre de variable a asignar
# 'orden' no puede tener tuberias '|', ignora el entrecomillado
#
# \\r    varize -e -m p n -- pgrep -l -r R
#
# \\r    varize -l 2 u df -h --output=used ; echo $u
#
# \\r    varize -e -n 3 -m x y -- echo no tampoco si tambien ignorado
#
# EN PROCESO - DEFINIENDO SEPARADOR DE CAMPOS NO FUNCIONA
#


[ $include_ctl ] || . include ; include enum # isnum - enum incluye isnum


varize(){
[ $# -gt 1 ] || { infsh ~/code/varize 3 23 ; return ;}
local varize_v="" varize_n="" varize_s=" " varize_e=true varize_l="" varize_c=0 varize_r="" varize_a=false varize_x="" varize_t=$tmp/varize
# v nombres-variables - n campos/comodin - s separador -- e echo - l linea - c campo - r resto/comodin - a archivo|comodin - x comodin - t tmp

while [ $# -ne 0 ] ; do case $1 in # opciones
	-e) varize_e=false ; shift ;;
	-m)	shift ; varize_v=$@ ; varize_v=${varize_v%% --*}
		enum -c $varize_v ; shift $(($?+1))
		set -- $@ ;	break ;;
    -l) varize_l=$2 ; shift 2 ;;
	-n) shift ; isnum $1 && {
			varize_c=$1 ; shift ; ! isnum $1 || { varize_r=$1 ; shift ;}
		} || varize_c=1 ;;
	-a) cp "$2" $varize_t ; varize_a=true ; shift 2 ;;
	-s) varize_s="$2" ; shift 2 ;;
	*) varize_v=$1 ; shift ; break ;;
esac ; done

$varize_a || "$@" > $varize_t # ejecucion orden

[ ${#varize_l} -eq 0 ] || { # linea
	[ $varize_l -eq 0 ] && { # ultima linea
		while read varize_a ; do varize_l=$varize_x varize_x=$varize_a ; done < $varize_t # por ultimo salto de linea
		[ ${#varize_x} -eq 0 ] || varize_l=$varize_x
	} || { # tal linea
		enum varize_a $varize_l
		for varize_x in $varize_a ; do read varize_l ; done < $varize_t
	}
	echo "$varize_l" > $varize_t
}

[ $varize_c -eq 0 ] || { # campos
	read varize_l < $varize_t
	IFS=$varize_s enum -c "$varize_l"
	[ $? -lt $varize_c ] && { # campo inexistente
		eval unset $varize_v # puede dar el valor que tenia antes
		return
	} || { # primer campo
		enum varize_a $((varize_c-1))
		for varize_x in $varize_a ; do varize_n=$varize_n'*'$varize_s ; done
		varize_n="${varize_l#$varize_n}"
		[ ${#varize_r} -ne 0 ] || { # por variables
				enum -c $varize_v ;
				varize_r=$((($?+varize_c)-1)) ;
		}  # ultimo campo
		IFS=$varize_s enum -c "$varize_l"
		enum varize_a $(($?-varize_r))
		varize_r=""
		for varize_x in $varize_a ; do varize_r=$varize_r$varize_s'*' ; done
		varize_n="${varize_n%$varize_r}"
		echo "$varize_n" > $varize_t
	}
}

[ "$varize_s" = " " ] && eval read $varize_v < $varize_t || eval IFS=$varize_s read $varize_v < $varize_t # asignacion a variables

$varize_e || { # echo
	for varize_x in $varize_v ; do eval varize_n=\$$varize_x
		echo "$varize_n" ;
	done
}
}


[ ${0##*/} != varize ] || varize "$@"
#
