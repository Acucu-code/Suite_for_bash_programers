<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="charset" content="UTF-8">
<meta name="language" content="en">
<meta name="resource-type" content="manual">
<meta name="keywords" content="shell bash tools include temperature-control sh text-coloring text-filtering text-styling">
<meta name="description" content="This suite contains sh scripts designed to complement programming with commands that, except in rare and forced cases, only use sh built-in commands.">
<!-- <meta name="revisit-after" content="7 days"> -->
<meta name="distribution" content="global">
<meta name="date" content="2025">
<meta name="author" content="acuku">
<!-- <link rel="shortcut icon" href="imagen/favicon.png" type="image/x-icon"> -->
<link rel="author" href="mailto:oxr@gmx.es">
<style>
	body{margin:1em 2.5em 1em 5em;}
	pre{padding:1em;border:1px solid black;width:auto;overflow-x:auto;}
	span{display:none;}
	pre:hover span{position:fixed;top:0;height:90%;padding:1em;background:azure;overflow-y:auto;display:block;}
</style>
<title>Suite for bash programers</title>
</head>
<body>
<a href="./chatgpt.html">A conversation with chatgpt about the dangers of AI</a>
<h1 title="Actualizado el 3/11/2025">Suite for bash programers</h1>
<pre><b>CHECK</b><br><span>
Checking Options
The actions are: [s]yes [enter|n]no [q]quit/cancel
The output is captured with '$?', yes>0 no>1 cancel>2 quit>3

	check [-] text && ... || ...

'-' does not end when pressing [q] when included in a script or bash shell with:

'. check', in bash it would close the terminal!!
</span></pre>
<pre><b>INCLUDE</b><br><span>
Manages the inclusion of code in a script or shell. The advantage of using it
instead of directly using '. file' is that it controls which files have been
included, either by another previously included file or in the extreme case of
two files mutually including each other; thus avoiding recursive inclusions
in the first case, and an infinite loop in the second. All of this applies to
inclusion in bash, except for controlling mutual inclusions.

From the 'bash' command line:

	. include [-l] script_1 [script_2 ...] # the first time, then without '.'

'-l' To see information about the inclusion process

In a 'sh' script:

	[ $include_ctl || ] . include ; include [-l] script_1 [script_2 ...]

The use of '$include_ctl' is to save processing.
</span></pre>
<pre><b>INFSH</b><br><span>
Adds color to a script header; by default, it colors some targets, but you can
specify others.

	infsh file start end [[style] target SEP [style] target ... ]

'file' from which to read the lines to display
'start end'
'style' [-c (0-7) or (00-77) for color/background] [-b] bold [-p] blinking
'target' to color. Enclose in quotation marks, or escape special characters '⧵c'
'SEP' '¬' instance separator.

'⧵⧵b' ensures that spaces/tabs are respected at the beginning of a comment
</span></pre>
<pre><b>ISNUM</b><br><span>
Indicates whether it is a number.

	isnum this

Accepts signed and unsigned numbers, integers, and decimals with and without
integer or decimal parts.

nº +nº -nº nº.mº +nº.mº -nº.mº .nº +.nº -.nº nº. +nº. -nº.

It will return 0 (true) if it is a number, 2 (error/false) if it is not a number,
and 1 (false) if nothing was entered.
</span></pre>
<pre><b>ENUM</b><br><span>
Enumerates a quantity of members or counts the words in a sentence

	enum [-e] [var] -c sentence | var number [c]

'-c' returns the number of words in the sentence, 'var' is optional
'var' is the name of the variable to which the result will be assigned
'n' is the quantity to enumerate
'c' is the starting point for enumeration, 0 by default
'-e' also displays the result

	enum x 3 ; for i in $x ; do ... ; done

	enum -c $sentence ; shift $?

The '. enum' tag must be included for the variable assignment to take effect
</span></pre>
<pre><b>FIN</b><br><span>
System shutdown management by time or temperature

	fin [[-+]t [nº]] [[-p]oweroff [-h]ibernate [-s]leep [-r]eboot]

'-t|+t' when the temperature drops or rises to nº, otherwise in nº or 300 seconds
'-[p|h|s|r]' action to perform, otherwise hibernate
</span></pre>
<pre><b>PARP</b><br><span>
Positionable text generator with styles and repetitions. Supports multiple
instances and the inclusion of instance files and escape sequences.

	parp [-l] [-s SEP] [options] [--] Text [SEP new instance [SEP ...]]

Parp accepts multiple options, in the following forms:
(S)symbol: S S+ S- S= SS
S SS Direct options: [¿ ! ¡ ¡¡ ç ^ v + - , ,, $ . º = : % _ __ @ --]
S+ S- S= SS To set a value: [ç+ ç= ^+ v+ ++ +- ,+ ,- ,= +$ -$ ^^ vv]
(-L)letter: Define spacing: [-z -w -W] Log: [-l] Include value: [-s -c -f -e -r -p -t -a -v]

SCREEN: ! invert_color ¿ revert ¡ delete ! and buffer ! - delete_cursor_up ! + down
CURSOR: ç start [ç= rowº columnº] [ç+ columnº] ^ [^+ upº] v [v+ downº] + [++ forwardº] - [+- backº]
JUMPS: ,, now , end [,+ linesº] [,- linesº] [,= lineº] $ tab [+$ tabsº] [-$ tabsº] [^^ scrollº] [vv scrollº]
STYLE: = normal_thickness º normal_brightness . off : blinking % inverse
STYLE: _ underline __ double_underline @ italic -c[(0-7) color (00-77) color/background] -f (0-7) background
FACILITY: Repeat [-e spaces] [-r n. characters] [-p n. words --] Log [-l]
FACILITY: Include [-t words --] [-a instance_file] [-v escape_file]
FACILITY: Separate: Instances [-s SEP] Space: Yes [-w] No [-z] Extra [-W] End_options [--]

The components of an instance share a style; for a different style, another instance.

The options [-z -w -W] transcend instances.

The options [-e -r -p -t -a -v] can be repeated within the same instance.

The default instance separator is '/'.

The log file '/tmp/code_$USER/parp.log', if the '-l' option is selected, contains
the program's output, which can be used to create instance and escape files.

Instances can be easily edited, and escape sequences can be used directly with 'cat'.
</span></pre>
<pre><b>PATH</b><br><span>
Converts a partial path to an absolute path and assigns it to a variable.

path [-e] var path

'-e' also displays the result.
'var' is the variable that will contain the absolute path.
'path' is the partial path, or not.

For assignment to a variable, '. path' must be included.
</span></pre>
<pre><b>RAND</b><br><span>
Returns a random number

	rand [min] max
</span></pre>
<pre><b>SHEAD</b><br><span>
Filter lines by content or prefix/suffix; highlight, delete, or replace; count;
and define the output mode.

	(|) shead (-a file) [-o file] [-t] [-l|-C] [-S SEP] [-n] ···
··· [-f nº|start [end]] [-z] [-b] [-u] [-P] [-c color] [-p|-pp|-s|-ss] ···
··· [-|!] [--] filter [-r replacement] [SEP new instance [SEP ...]]

General options:
'-a' reads from file, otherwise from standard output. '|' are mutually exclusive.
'-o' outputs to another file.
'-t' returns all lines in prefix/suffix mode.
'-l' displays the line number.
'-C' returns the number of matching lines; if '!', the resulting lines. by
	prefix/suffix always matches
'-S' separator, default is '/'
'-n' no style
'-f' will filter the last few lines. Last general option
'start end' lines to examine, all by default. Last general option
Instance options:
'-p|-s' will filter by prefix or suffix and act on them
'-pp|-ss' same but will act on the entire line
'-|-q' will not show the filter.
'!|-N' will not show lines with matches.
'-c' gives color to the filter or its replacement, color[0-7] color/background[00-77]
'-b' not bold
'-u' underline
'-P' blinking
'-z' will not make line breaks. In the last instance
'--' end of options, may be necessary if filter is a number.
'filter' text to find. Enclose in quotation marks if spaces or wildcards are present.
'-r' replace with 'replacement'.

By default, all lines are displayed and matches are highlighted.
Using 'pre/suffix' displays lines with matches without highlighting.
You can filter by content with '-p *filter' or '-s filter*' to show only the
matching lines; if color is specified, 'filter' cannot contain wildcards.
</span></pre>
<pre><b>SEP</b><br><span>
Separate instances and execute compound commands with each one.

	sep [-E|-L|-T]|[-s|-S SEP] [-R] [(+|-)N] [-O 'command..$sep_C..command..'] -A file|instances

General options:
'-A' reads instances from a file
'-O' command(s) to execute for each instance; if not specified, they will be displayed.

'-R' No carriage return
'$sep_C' literal, is the variable that contains each instance
'instances' can be: $insts|instSEPinst...|or nothing if reading from a file
Instance options:
'-E' space separator ' ', default
'-L' line feed separator
'-T' tab separator
'-s' separator, will be taken as spaces, ' SEP '
'-S' separator, no spaces 'SEP'
'-N' no strip, keep extra spaces and tabs. '+N' no, default
'--' end of options
</span></pre>
<pre><b>TB</b><br><span>
Captures the output of a command or reads from a file, and passes each line to a
script or command, which executes with each line received.

	(|) tb [-n] (-a file) command [arguments]

'-n' does not 'echo' after each execution from the pipe
</span></pre>
<pre><b>TEMPFREQ</b><br><span>
Control the temperature using cpufreq schedutil via scaling_max_freq.

	tempfreq  [0|interval] [0|repetitions] [0|amplitude] [0|temperature] log[true|false] &

	tempfreq l|i|h|q|aqui

At least one option must be provided:
'interval' refresh rate in seconds
'repetitions' number of repetitions or occurrences to apply the modulation
'amplitude' modulation range x ±100MHz
'temperature°' to not exceed
'log' - detailed information true/false

This is designed to run in the background, automatically.

	tempfreq 10 0 2 0 true & # '0' does not modify

sets the interval to 10", modulation amplitude to ⇐200 MHz and activates the log.

Once started, the following options are available:
'q' terminates the program
'l' shows/hides the log
'i' displays information
'h' displays help
'aqui' will bring its exit to the current tty

	tempfreq i # displays information about the program, variables, and log.

A longer interval and more repetitions result in greater frequency stability,
but a higher risk of overheating.
A larger amplitude allows for faster tuning, but reduces the operating range.
</span></pre>
<pre><b>TEMPFREQ_LOG</b><br><span>
Window for tempfreq with control options
</span></pre>
<pre><b>TIPO</b><br><span>
Determines the type of a command and returns (0|true) for functions and
(1-5|false) for all others:

function(0),alias(1),keyword(2),inner_command(3),file(4),doesnotexist(5).

	tipo [-e] command && is_function... || others...

	tipo command ; [ $? -lt 5 ] || echo "$1 is not a recognized command"

'-e' displays the type

'. tipo' must be included before it to identify functions, aliases, and files
</span></pre>
<pre><b>TIZE</b><br><span>
Style, delete, replace, or count occurrences in text

	tize [-e] [-s SEP] [-C] [-v var] [-a file] ···
	··· [-n]|[[-c nº -f nº] [-b] [-p] [-u]] ···
	··· [-q] target [-r replacement] [SEP new instance...] [--] SEP text

General options:
'-s' instance separator, '/' by default. Before '-a'.
'-C' counts the matches.
'-v' variable name to assign the result to.
'-a' reads from file, separators in a different file than the instance file.
'-e' 'echo' at the end.
Instance options:
'-c|-f' color and background formatting: -c (0-7 or more, background 00-77) -f (0-7).
'-b' not bold.
'-p' blinking.
'-u' underline.
'-n' no style.
'-q' removes occurrences.
'-r' replaces occurrences.
'--' end of options, if necessary.

For variable assignment, include: '. tize'
In 'text', if '-n' is not specified, all occurrences of 'target' or 'replacement'
will be colored. If 'color' or 'background' is not specified, they will be green
and normal, respectively.

If you're only coloring one character, put it in the first instance. If you want
to color more, it might fail due to escape sequences.
The encompassing characters '[',']', '{', and '}' should each be in a separate
instance and in that order.
Other special characters like ')' should be enclosed in quotation marks "(" or
escaped with \(
</span></pre>
<pre><b>TRIM</b><br><span>
Returns a portion of a string

	trim varname [-p|-s|posº] countº (only if '. trim' was included)

	trim [-n] [-p|-s|posº] countº string

'varname' Modifies the variable
'-n' Uses this mode even if the script was included
'-p|-s|posº' Extracts from the prefix, suffix (default), or from posº
'countº' Number of characters to extract
'string' String to trim and display
</span></pre>
<pre><b>TRIP</b><br><span>
Remove characters or merge repetitions in a string

	trip [-u] [-p|-s|-m] varname chars (only if '.trip' was included)

	trip [-n] [-u] [-p|-s|-m] chars string

'-u' Merges instead of removing
'-n' Use this mode even if the script was included
'-p|-s|-m' Acts on the beginning, end, or middle; by default, the entire string
'varname' Modifies this variable
'chars' Characters to remove
'string' String to modify and display

	user$ trip -u "⧵t" "/dev/sda1	ext3	..."
	/dev/sda1 ext3 ...
</span></pre>
<pre><b>VARIZE</b><br><span>
Assigns the output of a command or records from a file to one or more variables;
by line and field. Include '. varize' for the assignment to take effect.

	varize [-e] (-a file) [-l lº] [-n [cº [rº]]] {-m} var {var... [--]} (command)

'-e' displays the value.
'-a' specifies the file to read from, excluding 'command' and vice versa.
'-n' distributes across fields up to rº, or assigns to declared variables if rº
	is not present. If rº=0, the distribution will continue until the end; if rº
	is present and there is a remainder, it will be assigned to the last field.
'-l' reads from that line. Otherwise, it will be distributed among the variables.
```	If lº=0, it will be the last line.
'-m' multiple variables, '--' end of variables
'var' variable name to assign
'order' cannot contain pipes '|', ignores quotes

	varize -e -m p n -- pgrep -l -r R

	varize -l 2 u df -h --output=used ; echo $u

	varize -e -n 2 3 -m x y -- echo no si también tampoco
</span></pre>
</body>
</html>
